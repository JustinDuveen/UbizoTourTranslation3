<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICE Connectivity Diagnostic</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #569cd6;
            text-align: center;
        }
        .test-section {
            background-color: #252526;
            border: 1px solid #3e3e42;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        .log {
            background-color: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            padding: 10px;
            height: 500px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background-color: #1177bb;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.success { background-color: #4caf50; color: white; }
        .status.failure { background-color: #f44336; color: white; }
        .status.pending { background-color: #ff9800; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ICE Connectivity Diagnostic Tool</h1>
        
        <div class="test-section">
            <button id="testBasic" onclick="testBasicConnectivity()">Test Basic ICE</button>
            <button id="testPeerToPeer" onclick="testPeerToPeerICE()">Test Peer-to-Peer ICE</button>
            <button id="testFirewall" onclick="testFirewallConnectivity()">Test Firewall Issues</button>
            <span id="testStatus" class="status pending">Ready to Test</span>
        </div>
        
        <div class="test-section">
            <h3>Diagnostic Results</h3>
            <div id="logOutput" class="log">Click a test button to start diagnosing ICE connectivity issues...</div>
        </div>
    </div>

    <script>
        function log(message) {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            logOutput.textContent += `[${timestamp}] ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logOutput').textContent = '';
        }

        function setStatus(text, type) {
            const status = document.getElementById('testStatus');
            status.textContent = text;
            status.className = `status ${type}`;
        }

        // Test basic ICE candidate generation
        async function testBasicConnectivity() {
            clearLog();
            setStatus('Testing Basic ICE...', 'pending');
            log('=== BASIC ICE CONNECTIVITY TEST ===');
            
            const pc = new RTCPeerConnection({
                iceServers: [
                    {
                        urls: "turn:192.168.101.232:3478",
                        username: "username1",
                        credential: "password1"
                    },
                    {
                        urls: "turn:192.168.101.232:443",
                        username: "username1",
                        credential: "password1"
                    },
                    { urls: "stun:192.168.101.232:3478" },
                    { urls: "stun:stun.l.google.com:19302" }
                ],
                iceCandidatePoolSize: 15
            });

            let candidateCount = 0;
            let hasRelay = false;
            let hasSrflx = false;

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    candidateCount++;
                    const candidate = event.candidate.candidate;
                    log(`Candidate ${candidateCount}: ${candidate}`);
                    
                    if (candidate.includes('typ relay')) {
                        hasRelay = true;
                        log('✅ TURN relay candidate found');
                    }
                    if (candidate.includes('typ srflx')) {
                        hasSrflx = true;
                        log('✅ STUN server reflexive candidate found');
                    }
                } else {
                    log(`ICE gathering complete - ${candidateCount} total candidates`);
                    log(`TURN relay: ${hasRelay ? '✅' : '❌'}, STUN srflx: ${hasSrflx ? '✅' : '❌'}`);
                    
                    if (hasRelay && hasSrflx) {
                        setStatus('Basic ICE Working', 'success');
                    } else {
                        setStatus('Basic ICE Issues', 'failure');
                    }
                    pc.close();
                }
            };

            pc.createDataChannel('test');
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
        }

        // Test peer-to-peer ICE connectivity
        async function testPeerToPeerICE() {
            clearLog();
            setStatus('Testing P2P ICE...', 'pending');
            log('=== PEER-TO-PEER ICE CONNECTIVITY TEST ===');
            
            const config = {
                iceServers: [
                    {
                        urls: "turn:192.168.101.232:3478",
                        username: "username1",
                        credential: "password1"
                    },
                    { urls: "stun:192.168.101.232:3478" }
                ],
                iceCandidatePoolSize: 10
            };

            const pc1 = new RTCPeerConnection(config);
            const pc2 = new RTCPeerConnection(config);

            let pc1Candidates = [];
            let pc2Candidates = [];

            // Set up candidate exchange
            pc1.onicecandidate = (event) => {
                if (event.candidate) {
                    pc1Candidates.push(event.candidate);
                    log(`PC1 candidate: ${event.candidate.candidate.substring(0, 50)}...`);
                    pc2.addIceCandidate(event.candidate);
                }
            };

            pc2.onicecandidate = (event) => {
                if (event.candidate) {
                    pc2Candidates.push(event.candidate);
                    log(`PC2 candidate: ${event.candidate.candidate.substring(0, 50)}...`);
                    pc1.addIceCandidate(event.candidate);
                }
            };

            // Monitor connection states
            pc1.oniceconnectionstatechange = () => {
                log(`PC1 ICE state: ${pc1.iceConnectionState}`);
                if (pc1.iceConnectionState === 'connected' || pc1.iceConnectionState === 'completed') {
                    setStatus('P2P ICE Connected', 'success');
                } else if (pc1.iceConnectionState === 'failed') {
                    setStatus('P2P ICE Failed', 'failure');
                }
            };

            pc2.oniceconnectionstatechange = () => {
                log(`PC2 ICE state: ${pc2.iceConnectionState}`);
            };

            // Create data channels
            const dc1 = pc1.createDataChannel('test');
            pc2.ondatachannel = (event) => {
                log('✅ Data channel established');
            };

            // Start the connection process
            const offer = await pc1.createOffer();
            await pc1.setLocalDescription(offer);
            await pc2.setRemoteDescription(offer);

            const answer = await pc2.createAnswer();
            await pc2.setLocalDescription(answer);
            await pc1.setRemoteDescription(answer);

            // Timeout after 30 seconds
            setTimeout(() => {
                if (pc1.iceConnectionState !== 'connected' && pc1.iceConnectionState !== 'completed') {
                    log('❌ P2P connection timeout after 30 seconds');
                    setStatus('P2P ICE Timeout', 'failure');
                }
                pc1.close();
                pc2.close();
            }, 30000);
        }

        // Test for firewall/NAT issues
        async function testFirewallConnectivity() {
            clearLog();
            setStatus('Testing Firewall...', 'pending');
            log('=== FIREWALL/NAT CONNECTIVITY TEST ===');
            
            // Test different server configurations
            const testConfigs = [
                {
                    name: "Local TURN UDP",
                    config: {
                        iceServers: [{
                            urls: "turn:192.168.101.232:3478",
                            username: "username1",
                            credential: "password1"
                        }]
                    }
                },
                {
                    name: "Local TURN TCP",
                    config: {
                        iceServers: [{
                            urls: "turn:192.168.101.232:443",
                            username: "username1",
                            credential: "password1"
                        }]
                    }
                },
                {
                    name: "Local STUN",
                    config: {
                        iceServers: [{ urls: "stun:192.168.101.232:3478" }]
                    }
                },
                {
                    name: "Public STUN",
                    config: {
                        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
                    }
                }
            ];

            for (const testConfig of testConfigs) {
                log(`\n--- Testing ${testConfig.name} ---`);
                
                const pc = new RTCPeerConnection(testConfig.config);
                let candidateReceived = false;

                const candidatePromise = new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        resolve(false);
                    }, 5000);

                    pc.onicecandidate = (event) => {
                        if (event.candidate && !candidateReceived) {
                            candidateReceived = true;
                            clearTimeout(timeout);
                            log(`✅ ${testConfig.name}: ${event.candidate.candidate}`);
                            resolve(true);
                        }
                    };
                });

                pc.createDataChannel('test');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const result = await candidatePromise;
                if (!result) {
                    log(`❌ ${testConfig.name}: No candidates (timeout)`);
                }

                pc.close();
            }

            log('\n=== FIREWALL TEST COMPLETE ===');
            setStatus('Firewall Test Done', 'success');
        }
    </script>
</body>
</html>
