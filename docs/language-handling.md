# Language Handling in Tour Translator

## Overview

This document describes the standardized approach to language handling in the Tour Translator application. The application uses a centralized utility module to ensure consistent language normalization for storage operations while maintaining proper capitalization for UI display.

## Key Concepts

### Language Normalization

Languages in the Tour Translator application are handled in two formats:

1. **Storage Format**: Lowercase, used for Redis keys and internal operations
2. **Display Format**: Capitalized, used for UI display and user-facing content

This dual approach ensures consistent key lookup in Redis while providing a better user experience with properly formatted language names.

### Redis Key Standardization

All Redis keys related to languages follow standardized patterns generated by utility functions. This ensures consistency across the application and reduces the risk of key mismatches due to case sensitivity.

## Language Utilities

The language utilities are defined in `lib/languageUtils.ts` and provide the following functions:

### Language Formatting

```typescript
// Normalizes a language name for storage (lowercase)
normalizeLanguageForStorage(language: string): string

// Formats a language name for display (capitalized)
formatLanguageForDisplay(language: string): string
```

### Redis Key Generation

```typescript
// Generates a Redis key for a WebRTC offer
getOfferKey(tourId: string, language: string): string

// Generates a Redis key for supported languages set
getSupportedLanguagesKey(tourId: string): string

// Generates a Redis key for primary language
getPrimaryLanguageKey(tourId: string): string

// Generates a Redis key for language-specific attendees set
getLanguageAttendeesKey(tourId: string, language: string): string

// Generates a Redis key for attendee details
getAttendeeKey(tourId: string, attendeeId: string): string

// Generates alternative case versions of an offer key for fallback lookups
getAlternativeOfferKeys(tourId: string, language: string): string[]
```

### Transaction Utilities

```typescript
// Creates a transaction for clearing a placeholder and storing a real offer
createOfferTransaction(tourId: string, language: string, offerObject: any, expirySeconds?: number): RedisTransactionOperation[]
```

### Validation Utilities

```typescript
// Validates a WebRTC SDP offer object
validateSdpOffer(offer: any): { isValid: boolean; error?: string }
```

## Usage Guidelines

### API Routes

When handling languages in API routes:

1. Import the necessary utilities:
   ```typescript
   import { 
     normalizeLanguageForStorage, 
     formatLanguageForDisplay,
     getOfferKey,
     // other utilities as needed
   } from "@/lib/languageUtils";
   ```

2. Normalize language parameters from requests:
   ```typescript
   const languageParam = req.query.language;
   const language = normalizeLanguageForStorage(languageParam);
   ```

3. Use utility functions for Redis key generation:
   ```typescript
   const offerKey = getOfferKey(tourId, language);
   const supportedLanguagesKey = getSupportedLanguagesKey(tourId);
   ```

4. Include both normalized and display formats in responses:
   ```typescript
   return {
     language: normalizedLanguage,
     displayLanguage: formatLanguageForDisplay(normalizedLanguage),
     // other response data
   };
   ```

### UI Components

When handling languages in UI components:

1. Import the necessary utilities:
   ```typescript
   import { 
     normalizeLanguageForStorage, 
     formatLanguageForDisplay 
   } from "@/lib/languageUtils";
   ```

2. Normalize language input before storage or API calls:
   ```typescript
   const handleLanguageChange = (newLanguage: string) => {
     const normalizedLanguage = normalizeLanguageForStorage(newLanguage);
     setLanguage(normalizedLanguage);
   };
   ```

3. Format languages for display:
   ```typescript
   <SelectItem value={normalizedLang}>
     {formatLanguageForDisplay(normalizedLang)}
   </SelectItem>
   ```

## Redis Key Patterns

The following Redis key patterns are used in the application:

| Entity | Key Pattern | Utility Function |
|--------|-------------|------------------|
| WebRTC Offer | `tour:{tourId}:offer:{language}` | `getOfferKey()` |
| Supported Languages | `tour:{tourId}:supported_languages` | `getSupportedLanguagesKey()` |
| Primary Language | `tour:{tourId}:primary_language` | `getPrimaryLanguageKey()` |
| Language Attendees | `tour:{tourId}:language:{language}:attendees` | `getLanguageAttendeesKey()` |
| Attendee Details | `tour:{tourId}:attendee:{attendeeId}` | `getAttendeeKey()` |

## Backward Compatibility

For backward compatibility with existing Redis keys that might use different case formats, the application uses the `getAlternativeOfferKeys()` function to generate and try alternative key formats when the primary key is not found.

Example:
```typescript
// Try to get the offer using the primary key first
let offerJson = await redis.get(primaryOfferKey);

// If not found, try alternative keys for backward compatibility
if (!offerJson) {
  const alternativeKeys = getAlternativeOfferKeys(tourId, language);
  
  // Try each alternative key
  for (const altKey of alternativeKeys) {
    if (altKey === primaryOfferKey) continue; // Skip the primary key we already tried
    
    offerJson = await redis.get(altKey);
    if (offerJson) {
      console.log(`Found offer using alternative key: ${altKey}`);
      break;
    }
  }
}
```

## Best Practices

1. **Always normalize languages for storage operations**:
   ```typescript
   const normalizedLanguage = normalizeLanguageForStorage(language);
   ```

2. **Always format languages for UI display**:
   ```typescript
   const displayLanguage = formatLanguageForDisplay(language);
   ```

3. **Use utility functions for Redis key generation**:
   ```typescript
   const offerKey = getOfferKey(tourId, language);
   ```

4. **Include both normalized and display formats in API responses**:
   ```typescript
   return {
     language: normalizedLanguage,
     displayLanguage: displayLanguage,
     // other response data
   };
   ```

5. **Validate SDP offers before storage**:
   ```typescript
   const validation = validateSdpOffer(offer);
   if (!validation.isValid) {
     // Handle invalid offer
   }
   ```

6. **Use atomic transactions for critical operations**:
   ```typescript
   const operations = createOfferTransaction(tourId, language, offerObject);
   await executeRedisTransaction(operations);
   ```

## Troubleshooting

### Common Issues

1. **Redis key not found**:
   - Check if the language is properly normalized
   - Try using `getAlternativeOfferKeys()` to find alternative key formats

2. **Language not displayed correctly in UI**:
   - Ensure `formatLanguageForDisplay()` is used for UI rendering

3. **SDP validation failures**:
   - Check the SDP content format
   - Look for escaped characters that might need fixing

### Debugging

For debugging language-related issues, the application includes detailed logging:

```typescript
console.log(`Language: ${languageParam} (normalized: ${language}, display: ${displayLanguage})`);
console.log(`Redis key: ${offerKey}`);
```

## Migration

When migrating existing data to the new language handling approach:

1. Identify Redis keys that use non-normalized language formats
2. Create new keys with normalized language formats
3. Copy data from old keys to new keys
4. Implement fallback mechanisms for backward compatibility

## Conclusion

The centralized language handling approach ensures consistency across the Tour Translator application, reducing the risk of case sensitivity issues and improving the overall user experience. By following the guidelines in this document, developers can maintain this consistency and build upon the foundation established in Phase 3 of the implementation plan.
